1. Назначение

Проект строит план размещения грузовых единиц (паллет/тары) в кузове ТС по данным из WMS/БД и визуализирует результат в 3D в Chrome-расширении.
Выход системы: JSON с параметрами ТС, списком паллет и их координатами/габаритами/статусами + отдельная зона для того, что не поместилось.

2. Архитектура и поток данных

Шаг 1. Получение данных

Клиент (Chrome extension) запрашивает последний task_id из background/storage.

Затем background вызывает серверный endpoint:

GET /api/load-plan/by-task/{task_id}

Шаг 2. Сервер формирует вход для упаковщика

Сервер достаёт строки по task_id из БД (SQL join по задачам/упаковкам/контейнерам).

Каждая строка нормализуется в объект “паллеты” (габариты, высота, вес, тип, статусы, признаки штабелирования).

Тип ТС маппится в пресет габаритов кузова.

Шаг 3. Packing (план раскладки)

Алгоритм размещает паллеты на полу кузова + делает второй проход штабелирования (2-й уровень).

То, что не удалось поставить/настакать, отправляется в “unplaced-зону” (справа от ТС) с координатами вне кузова.

Шаг 4. Клиентская визуализация

Viewer рисует кузов и паллеты.

“Не влезло” определяется как “не внутри кузова” (по aabb либо по вычисленному AABB).

Для “не влезло” рисуется отдельная зона и подписи sscc/id (только там).

Статистика в UI считается по факту нахождения внутри кузова.

3. Разбиение по модулям (кто за что отвечает)

3.1. server.py (точка входа API)
Ответственность:

Поднять FastAPI и CORS.

Endpoint /api/load-plan/by-task/{task_id}:

вызывает fetch_task_rows(task_id)

выбирает габариты ТС (через пресеты)

нормализует строки в паллеты (normalize_pallet)

устраняет дубли sscc (делает уникальные id вида sscc__2)

вызывает packing (pack_rows_with_stacking)

возвращает итоговый JSON: vehicle, stats, pallets

3.2. settings.py
Ответственность:

load_dotenv()

чтение DATABASE_URL из окружения

3.3. db.py
Ответственность:

создание engine = create_engine(DATABASE_URL, pool_pre_ping=True)

3.4. catalogs/vehicles.py
Ответственность:

VEHICLE_PRESETS (словарь тип ТС → внутренние габариты)

DEFAULT_VEHICLE (fallback)

3.5. catalogs/packaging_catalog.py
Ответственность:

TARA_CATALOG_CM (справочник тары)

единицы: размеры в см, вес в кг
Примечание:

server.py не хранит каталог внутри себя, только импортирует.

3.6. services/fetch.py
Ответственность:

fetch_task_rows(task_id):

выполняет SQL и возвращает список dict строк:

task_id, route_id, transport_type, sscc, weight, height, volume, pallet_type

3.7. services/normalize.py
Ответственность:

нормализация и интерпретация сырых данных в “паллета-объект”
Ключевые функции:

normalize_code_key():

приводит ключ к единому виду (upper, trim, “Х”→”X”)

lookup_tara_by_code():

ищет pallet_type в TARA_CATALOG_CM

parse_pallet_type() (fallback):

парсит размеры из строк вида PAL 80X120 или BOX 40X40X60

get_stack_flags() (временная заглушка):

возвращает can_be_base / can_be_stacked (по умолчанию true)

normalize_pallet(row):

определяет ширину/длину:

приоритет 1: справочник тары

приоритет 2: парсинг из pallet_type

приоритет 3: дефолт 0.8×1.2

определяет высоту:

приоритет 1: из volume (volume / base_area)

приоритет 2: из actual height

приоритет 3: из BOX-парсинга

иначе дефолт 1.2

определяет вес:

если actual weight пустой, берёт tare weight из справочника (если есть)

выставляет status (источник габаритов/высоты)

выставляет canBeBase / canBeStacked

3.8. services/packing.py
Ответственность:

алгоритм размещения в кузове и формирование координат/вращений/AABB
Ключевые части:

AABB и коллизии:

aabb_from_center()

aabb_intersects()

collides_with_any()

Floor packing (1-й проход):

свободное пространство хранится прямоугольниками (free_rects)

используется разбиение прямоугольников при размещении (split/prune)

выбор “лучшего хода” по скорингу:

одиночная паллета (single)

композит 3+2 для 80×120

композит zigzag на 10 паллет

Stacking (2-й проход):

собираются базы (паллета внизу), если canBeBase

кандидаты на верх:

проверка габаритов по базе

проверка веса (base_weight >= top_weight, если оба известны)

проверка коллизий и потолка

выбор лучшей базы по score (минимальный slack, ниже topY, предпочтение более тяжёлой базы)

лог попыток может прикладываться в debug к unplaced (чтобы разбирать причины)

Unplaced-зона:

если не удалось разместить/настакать:

объект получает unplaced: true

координаты ставятся вне кузова (справа), чтобы viewer их видел

3.9. domain/types.py
Ответственность:

типы (TypedDict) для единообразия структур:

Vehicle, Pallet, AABB, LoadPlanResponse (при необходимости)

4. Контракты данных (JSON)

Ответ /api/load-plan/by-task/{task_id}:

taskId, routeId, transportType

vehicle: { innerWidth, innerHeight, innerLength } в метрах

stats: { total, placed, unplaced }

pallets: массив объектов:

входные поля: id, width, length, height, weight, volume, palletType, palletTypeNorm

выходные поля packing: x, y, z, rotationY, dims{dx,dy,dz}, aabb{min/max}, corner{x0,y0,z0}

служебные: status, unplaced, stackedOn, debug(опционально)

5. Логика “не влезло” и визуализация

Критерий “в кузове”

viewer определяет “в кузове” как:

если есть aabb: проверяет, что min/max внутри границ кузова

иначе вычисляет AABB по центру и габаритам

всё что не внутри кузова → “не влезло” (даже если x/y/z заданы)

Отрисовка

В кузове: паллеты без подписей

Не влезло: отдельная зона справа + подписи id/sscc только там

Цвет/подсветка зависит от status (например too_tall/no_space ярче)

6. Где менять поведение

Добавить/поправить тару: catalogs/packaging_catalog.py

Добавить тип ТС/габариты: catalogs/vehicles.py

Изменить SQL/поля входа: services/fetch.py

Изменить правила нормализации (высота/вес/габариты): services/normalize.py

Изменить алгоритм упаковки/стекования/unplaced: services/packing.py

Изменить визуальную логику “не влезло”, подписи, сортировку: viewer.js

7. Принципы

Сервер отвечает за вычисление координат и статусов, клиент — за корректное визуальное разделение “в кузове / не влезло”.

Каталоги (ТС, тара) вынесены отдельно и импортируются, чтобы server.py не превращался в монолит.

Все критичные решения помечаются status, чтобы быстро понимать источник данных и причины “не влезло”.